"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = exports.getTitle = exports.getLinesToToc = exports.countHeaders = exports.getMarkdownHeaders = exports.matchesEnd = exports.matchesStart = void 0;
const anchor_markdown_header_1 = require("@technote-space/anchor-markdown-header");
const update_section_1 = __importDefault(require("update-section"));
const md = __importStar(require("@textlint/markdown-to-ast"));
const get_html_headers_1 = require("./get-html-headers");
const __1 = require("..");
const getTargetComments = (checkComments, defaultComments) => {
    if (checkComments.length) {
        return checkComments;
    }
    return [defaultComments];
};
const matchesStart = (checkOpeningComments) => (line) => getTargetComments(checkOpeningComments !== null && checkOpeningComments !== void 0 ? checkOpeningComments : [], __1.CHECK_OPENING_COMMENT).some(comment => new RegExp(comment).test(line));
exports.matchesStart = matchesStart;
const matchesEnd = (checkClosingComments) => (line) => getTargetComments(checkClosingComments !== null && checkClosingComments !== void 0 ? checkClosingComments : [], __1.CHECK_CLOSING_COMMENT).some(comment => new RegExp(comment).test(line));
exports.matchesEnd = matchesEnd;
const addAnchor = (mode, moduleName, header) => {
    return Object.assign(Object.assign({}, header), { anchor: anchor_markdown_header_1.anchor(header.name, mode, header.repetition, moduleName) });
};
// eslint-disable-next-line no-magic-numbers
const shouldEscape = (header) => /^#+\s+/.test(header.raw) && !/\s+#+$/.test(header.raw) && header.children.length === 1 && header.children[0].type === md.Syntax.Str;
const escapeHeader = (header) => md.parse(header.raw.replace(/^#+\s+/, '').replace('&#035;', '#').replace('#', '&#035;').replace(']', '&#93;').replace('[', '&#91;').trim());
const getMarkdownHeaders = (lines, maxHeaderLevel) => {
    const extractText = (header) => {
        const target = shouldEscape(header) ? escapeHeader(header) : header;
        return target.children
            .map(node => {
            if (node.type === md.Syntax.Link) {
                return extractText(node);
            }
            if (node.type === md.Syntax.Image) {
                // Images (at least on GitHub, untested elsewhere) are given a hyphen
                // in the slug. We can achieve this behavior by adding an '*' to the
                // TOC entry. Think of it as a "magic char" that represents the iamge.
                return '*';
            }
            return node.raw;
        }).join('');
    };
    const toHeader = (header) => !maxHeaderLevel || header.depth <= maxHeaderLevel ? {
        line: header.loc.start.line,
        rank: header.depth,
        name: extractText(header),
    } : null;
    return md.parse(lines.join('\n')).children.filter((node) => node.type === md.Syntax.Header).map(toHeader).filter(item => item !== null);
};
exports.getMarkdownHeaders = getMarkdownHeaders;
const countHeaders = (headers, mode, moduleName) => {
    const repetitions = {};
    return headers.map(header => {
        const name = anchor_markdown_header_1.getUrlHash(header.name, mode, undefined, moduleName);
        if (Object.prototype.hasOwnProperty.call(repetitions, name)) {
            repetitions[name]++;
        }
        else {
            repetitions[name] = 0;
        }
        return Object.assign(Object.assign({}, header), { repetition: repetitions[name] });
    });
};
exports.countHeaders = countHeaders;
const getLinesToToc = (lines, currentToc, info, processAll) => {
    if (processAll || !currentToc) {
        return lines;
    }
    // when updating an existing toc, we only take the headers into account
    // that are below the existing toc
    if (info.hasEnd) {
        // eslint-disable-next-line no-magic-numbers
        return lines.slice(info.endIdx + 1);
    }
    return lines;
};
exports.getLinesToToc = getLinesToToc;
const getTitle = (title, lines, info) => {
    if (title) {
        return title;
    }
    // eslint-disable-next-line no-magic-numbers
    return info.hasStart ? lines[info.startIdx + 2] : __1.DEFAULT_TITLE;
};
exports.getTitle = getTitle;
const wrapTitle = (title, isFolding) => isFolding && title !== '' ? `<summary>${title.replace(/^([*_]*)(.+)\1$/, '$2')}</summary>` : title;
const wrapToc = (toc, title, isFolding) => isFolding && title !== '' ? `<details>\n${toc}\n</details>` : toc;
// Use document context as well as command line args to infer the title
const determineTitle = (title, isNotitle, isFolding, lines, info) => {
    if (isNotitle) {
        return '';
    }
    return wrapTitle(exports.getTitle(title, lines, info), isFolding);
};
const transform = (content, { mode, moduleName, maxHeaderLevel, title, isNotitle, isFolding, entryPrefix, processAll, updateOnly, openingComment, closingComment, checkOpeningComments, checkClosingComments, } = {}) => {
    mode = mode || 'github.com';
    entryPrefix = entryPrefix || '-';
    // only limit *HTML* headings by default
    // eslint-disable-next-line no-magic-numbers
    const maxHeaderLevelHtml = maxHeaderLevel || 4;
    const lines = content.split('\n');
    const info = update_section_1.default.parse(lines, exports.matchesStart(checkOpeningComments), exports.matchesEnd(checkClosingComments));
    if (!info.hasStart && updateOnly) {
        return {
            transformed: false,
            data: '',
            toc: '',
            wrappedToc: '',
            reason: 'update only',
        };
    }
    // eslint-disable-next-line no-magic-numbers
    const currentToc = info.hasStart && lines.slice(info.startIdx, info.endIdx + 1).join('\n');
    const linesToToc = exports.getLinesToToc(lines, currentToc, info, processAll);
    const headers = exports.getMarkdownHeaders(linesToToc, maxHeaderLevel).concat(get_html_headers_1.getHtmlHeaders(linesToToc, maxHeaderLevelHtml));
    headers.sort((header1, header2) => header1.line - header2.line);
    const allHeaders = exports.countHeaders(headers, mode, moduleName);
    const lowestRank = Math.min(...allHeaders.map(header => header.rank));
    const linkedHeaders = allHeaders.map(header => addAnchor(mode, moduleName, header));
    const inferredTitle = linkedHeaders.length ? determineTitle(title, isNotitle, isFolding, lines, info) : '';
    const titleSeparator = inferredTitle ? '\n\n' : '\n';
    // 4 spaces required for proper indention on Bitbucket and GitLab
    const indentation = (mode === 'bitbucket.org' || mode === 'gitlab.com') ? '    ' : '  ';
    const toc = inferredTitle +
        titleSeparator +
        linkedHeaders.map(header => indentation.repeat(header.rank - lowestRank) + entryPrefix + ' ' + header.anchor).join('\n') +
        '\n';
    const wrappedToc = (openingComment !== null && openingComment !== void 0 ? openingComment : __1.OPENING_COMMENT) + '\n' + wrapToc(toc, inferredTitle, isFolding) + '\n' + (closingComment !== null && closingComment !== void 0 ? closingComment : __1.CLOSING_COMMENT);
    if (currentToc === wrappedToc) {
        return {
            transformed: false,
            data: '',
            toc: '',
            wrappedToc: '',
            reason: 'not updated',
        };
    }
    return {
        transformed: true,
        data: update_section_1.default(lines.join('\n'), wrappedToc, exports.matchesStart(checkOpeningComments), exports.matchesEnd(checkClosingComments), true),
        toc,
        wrappedToc,
        reason: '',
    };
};
exports.transform = transform;
exports.default = exports.transform;
